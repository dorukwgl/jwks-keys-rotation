package com.doruk.controller;

import com.doruk.dto.TokenRequest;
import com.doruk.dto.TokenResponse;
import com.doruk.service.JwtService;
import io.micronaut.context.annotation.Value;
import io.micronaut.http.HttpResponse;
import io.micronaut.http.annotation.Body;
import io.micronaut.http.annotation.Controller;
import io.micronaut.http.annotation.Post;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Authentication controller for JWT token generation.
 */
@Controller("/auth")
public class AuthController {

    private static final Logger LOG = LoggerFactory.getLogger(AuthController.class);

    private final JwtService jwtService;
    private final long tokenExpiryMinutes;

    public AuthController(JwtService jwtService,
                          @Value("${jwt.token.expiry-minutes:10}") long tokenExpiryMinutes) {
        this.jwtService = jwtService;
        this.tokenExpiryMinutes = tokenExpiryMinutes;
    }

    /**
     * Generate a JWT token for the given subject.
     *
     * POST /auth/token
     * Body: {"subject": "username"}
     */
    @Post("/token")
    public HttpResponse<TokenResponse> generateToken(@Valid @Body TokenRequest request) {
        LOG.debug("Generating token for subject: {}", request.getSubject());

        try {
            String token = jwtService.generateToken(request.getSubject(), request.getAudience());

            TokenResponse response = new TokenResponse(token, tokenExpiryMinutes * 60);
            return HttpResponse.ok(response);

        } catch (Exception e) {
            LOG.error("Failed to generate token", e);
            return HttpResponse.serverError();
        }
    }
}package com.doruk.controller;

import com.doruk.service.KeyStorageService;
import com.nimbusds.jose.jwk.ECKey;
import io.micronaut.http.MediaType;
import io.micronaut.http.annotation.Controller;
import io.micronaut.http.annotation.Get;
import io.micronaut.http.annotation.Produces;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * JWKS (JSON Web Key Set) endpoint controller.
 * Exposes public keys for JWT validation.
 */
@Controller("/.well-known")
public class JwksController {

    private static final Logger LOG = LoggerFactory.getLogger(JwksController.class);

    private final KeyStorageService keyStorageService;

    public JwksController(KeyStorageService keyStorageService) {
        this.keyStorageService = keyStorageService;
    }

    /**
     * Get JWKS (JSON Web Key Set) containing public keys.
     *
     * GET /.well-known/jwks.json
     *
     * Returns both primary and secondary public keys for token validation.
     */
    @Get("/jwks.json")
    @Produces(MediaType.APPLICATION_JSON)
    public Map<String, Object> getJwks() {
        LOG.debug("JWKS endpoint called");

        try {
            ECKey primaryKey = keyStorageService.getPrimaryKey();
            ECKey secondaryKey = keyStorageService.getSecondaryKey();

            // Convert to public keys only (remove private key material)
            Map<String, Object> primaryPublic = primaryKey.toPublicJWK().toJSONObject();
            Map<String, Object> secondaryPublic = secondaryKey.toPublicJWK().toJSONObject();

            Map<String, Object> jwks = new HashMap<>();
            jwks.put("keys", List.of(primaryPublic, secondaryPublic));

            return jwks;

        } catch (Exception e) {
            LOG.error("Failed to generate JWKS", e);
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Failed to retrieve keys");
            return error;
        }
    }
}package com.doruk.controller;

import com.doruk.service.KeyRotationScheduler;
import io.micronaut.http.HttpResponse;
import io.micronaut.http.annotation.Controller;
import io.micronaut.http.annotation.Get;
import io.micronaut.http.annotation.Post;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

/**
 * Controller for key rotation management.
 */
@Controller("/rotation")
public class RotationController {

    private final KeyRotationScheduler rotationScheduler;

    public RotationController(KeyRotationScheduler rotationScheduler) {
        this.rotationScheduler = rotationScheduler;
    }

    /**
     * Manually trigger key rotation.
     *
     * POST /rotation/trigger
     */
    @Post("/trigger")
    public HttpResponse<Map<String, Object>> triggerRotation() {
        boolean success = rotationScheduler.triggerManualRotation();

        Map<String, Object> response = new HashMap<>();
        response.put("success", success);
        response.put("message", success ? "Key rotation completed" : "Key rotation failed");
        response.put("timestamp", java.time.Instant.now().toString());

        return success ? HttpResponse.ok(response) : HttpResponse.serverError(response);
    }

    /**
     * Get rotation status and statistics.
     *
     * GET /rotation/status
     */
    @Get("/status")
    public HttpResponse<Map<String, Object>> getRotationStatus() {
        KeyRotationScheduler.RotationStats stats = rotationScheduler.getStats();

        Map<String, Object> response = new HashMap<>();
        response.put("enabled", stats.enabled());
        response.put("totalRotations", stats.totalRotations());
        response.put("lastRotation", stats.lastRotation().toString());
        response.put("nextRotationIn", formatDuration(stats.timeUntilNext()));
        response.put("nextRotationMinutes", stats.timeUntilNext().toMinutes());

        return HttpResponse.ok(response);
    }

    private String formatDuration(Duration duration) {
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long seconds = duration.toSecondsPart();

        if (hours > 0) {
            return String.format("%dh %dm %ds", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds);
        } else {
            return String.format("%ds", seconds);
        }
    }
}package com.doruk.dto;

import com.nimbusds.jose.jwk.ECKey;

public record ActiveKeys(ECKey primary, ECKey secondary) {}

package com.doruk.dto;

import io.micronaut.core.annotation.Introspected;
import io.micronaut.serde.annotation.Serdeable;
import jakarta.validation.constraints.NotBlank;

/**
 * Request DTO for token generation.
 * Contains the subject (username or identifier) for which to generate a JWT token.
 */
@Introspected
@Serdeable
public class TokenRequest {
    @NotBlank
    private String aud;

    @NotBlank
    private String sub;

    public TokenRequest() {
    }

    public TokenRequest(String subject) {
        this.sub = subject;
    }

    public String getSubject() {
        return sub;
    }

    public String getAudience() {
        return aud;
    }

    public void setSubject(String subject) {
        this.sub = subject;
    }
}package com.doruk.dto;

import io.micronaut.core.annotation.Introspected;
import io.micronaut.serde.annotation.Serdeable;

/**
 * Response DTO for token generation.
 * Contains the generated JWT access token and its type.
 */
@Introspected
@Serdeable
public class TokenResponse {

    private String accessToken;
    private String tokenType = "Bearer";
    private Long expiresIn;

    public TokenResponse() {
    }

    public TokenResponse(String accessToken, Long expiresIn) {
        this.accessToken = accessToken;
        this.expiresIn = expiresIn;
    }

    public String getAccessToken() {
        return accessToken;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public String getTokenType() {
        return tokenType;
    }

    public void setTokenType(String tokenType) {
        this.tokenType = tokenType;
    }

    public Long getExpiresIn() {
        return expiresIn;
    }

    public void setExpiresIn(Long expiresIn) {
        this.expiresIn = expiresIn;
    }
}package com.doruk.service;

import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.crypto.ECDSASigner;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import io.micronaut.context.annotation.Value;
import jakarta.inject.Singleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Date;
import java.util.UUID;

/**
 * Simple JWT service for signing and validating tokens.
 * Uses ES256 (ECDSA with P-256 curve) for signing.
 */
@Singleton
public class JwtService {

    private static final Logger LOG = LoggerFactory.getLogger(JwtService.class);

    private final KeyStorageService keyStorageService;
    private final long tokenExpiryMinutes;

    public JwtService(KeyStorageService keyStorageService,
                      @Value("${jwt.token.expiry-minutes:10}") long tokenExpiryMinutes) {
        this.keyStorageService = keyStorageService;
        this.tokenExpiryMinutes = tokenExpiryMinutes;
    }

    /**
     * Generate a signed JWT token for the given subject.
     *
     * @param subject the subject (username/identifier)
     * @return signed JWT as string
     */
    public String generateToken(String subject, String audience) {
        try {
            ECKey primaryKey = keyStorageService.getPrimaryKey();

            // Create JWT claims
            Instant now = Instant.now();

            JWTClaimsSet claims = new JWTClaimsSet.Builder()
                    .subject(subject)
                    .issuer("com.doruk.jwks")
                    .audience(audience)
                    .issueTime(Date.from(now))
                    .notBeforeTime(Date.from(now))
                    .expirationTime(Date.from(now.plusSeconds(tokenExpiryMinutes * 60)))
                    .jwtID(UUID.randomUUID().toString())
                    .build();

            // Create JWT header with key ID
            JWSHeader header = new JWSHeader.Builder(JWSAlgorithm.ES256)
                    .keyID(primaryKey.getKeyID())
                    .build();

            // Create signed JWT
            SignedJWT signedJWT = new SignedJWT(header, claims);

            // Sign with primary key
            JWSSigner signer = new ECDSASigner(primaryKey);
            signedJWT.sign(signer);

            String token = signedJWT.serialize();
            LOG.debug("Generated token for subject: {} with key ID: {}", subject, primaryKey.getKeyID());

            return token;

        } catch (Exception e) {
            LOG.error("Failed to generate token", e);
            throw new RuntimeException("Token generation failed", e);
        }
    }
}package com.doruk.service;

import io.micronaut.context.annotation.Requires;
import io.micronaut.context.annotation.Value;
import io.micronaut.scheduling.annotation.Scheduled;
import jakarta.inject.Singleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;

/**
 * Scheduled task for automatic key rotation.
 */
@Singleton
@Requires(property = "jwk.rotation.enabled", value = "true", defaultValue = "true")
public class KeyRotationScheduler {

    private static final Logger LOG = LoggerFactory.getLogger(KeyRotationScheduler.class);

    private final KeyStorageService keyStorageService;
    private final boolean rotationEnabled;
    private final long rotationIntervalMinutes;

    private Instant lastRotation = Instant.now();
    private int rotationCount = 0;

    public KeyRotationScheduler(
            KeyStorageService keyStorageService,
            @Value("${jwk.rotation.enabled:true}") boolean rotationEnabled,
            @Value("${jwk.rotation.interval-minutes:20}") long rotationIntervalMinutes) {
        this.keyStorageService = keyStorageService;
        this.rotationEnabled = rotationEnabled;
        this.rotationIntervalMinutes = rotationIntervalMinutes;

        LOG.info("Key rotation scheduler initialized");
        LOG.info("Rotation enabled: {}", rotationEnabled);
        LOG.info("Rotation interval: {} minutes", rotationIntervalMinutes);
    }

    @Scheduled(fixedDelay = "${jwk.rotation.interval-minutes:20}m",
            initialDelay = "${jwk.rotation.initial-delay-minutes:20}m")
    public void rotateKeys() {
        if (!rotationEnabled) {
            return;
        }

        try {
            LOG.info("=== Starting scheduled key rotation #{} ===", rotationCount + 1);

            keyStorageService.rotateKeys();

            lastRotation = Instant.now();
            rotationCount++;

            LOG.info("=== Key rotation completed successfully ===");

        } catch (Exception e) {
            LOG.error("Key rotation failed!", e);
        }
    }

    public boolean triggerManualRotation() {
        LOG.warn("Manual key rotation triggered");
        try {
            keyStorageService.rotateKeys();
            lastRotation = Instant.now();
            rotationCount++;
            LOG.info("Manual key rotation completed successfully");
            return true;
        } catch (Exception e) {
            LOG.error("Manual key rotation failed", e);
            return false;
        }
    }

    public RotationStats getStats() {
        Duration elapsed = Duration.between(lastRotation, Instant.now());
        Duration remaining = Duration.ofMinutes(rotationIntervalMinutes).minus(elapsed);
        if (remaining.isNegative()) {
            remaining = Duration.ZERO;
        }

        return new RotationStats(
                rotationCount,
                lastRotation,
                remaining,
                rotationEnabled
        );
    }

    public record RotationStats(
            int totalRotations,
            Instant lastRotation,
            Duration timeUntilNext,
            boolean enabled
    ) {}
}package com.doruk.service;

import com.doruk.dto.ActiveKeys;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.jwk.Curve;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.gen.ECKeyGenerator;
import io.micronaut.context.annotation.Value;
import jakarta.inject.Singleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.Instant;
import java.util.UUID;

/**
 * Service for managing key storage and generation.
 * Handles file-based persistence of primary and secondary keys.
 */
@Singleton
public class KeyStorageService {

    private static final Logger LOG = LoggerFactory.getLogger(KeyStorageService.class);

    private final Path keysDirectory;
    private final Path primaryKeyPath;
    private final Path secondaryKeyPath;
    private final Path metadataPath;

    private volatile ActiveKeys activeKeys;

    public KeyStorageService(@Value("${jwk.storage.directory:./keys}") String keysDirectory) {
        this.keysDirectory = Paths.get(keysDirectory);
        this.primaryKeyPath = this.keysDirectory.resolve("primary.jwk");
        this.secondaryKeyPath = this.keysDirectory.resolve("secondary.jwk");
        this.metadataPath = this.keysDirectory.resolve("metadata.json");

        initialize();
    }

    private void initialize() {
        try {
            // Create directory if needed
            if (!Files.exists(keysDirectory)) {
                Files.createDirectories(keysDirectory);
                LOG.info("Created keys directory: {}", keysDirectory);
            }

            // Load or generate keys
            if (!Files.exists(primaryKeyPath) || !Files.exists(secondaryKeyPath)) {
                LOG.info("Keys not found. Generating new key pair...");
                generateInitialKeys();
            } else {
                loadKeys();
            }
        } catch (Exception e) {
            LOG.error("Failed to initialize key storage", e);
            throw new RuntimeException("Key storage initialization failed", e);
        }
    }

    private void generateInitialKeys() throws JOSEException, IOException {
        LOG.info("Generating initial EC P-256 key pair...");

        var primaryKey = new ECKeyGenerator(Curve.P_256)
                .keyUse(KeyUse.SIGNATURE)
                .keyID("primary-" + UUID.randomUUID().toString().substring(0, 8))
                .algorithm(com.nimbusds.jose.JWSAlgorithm.ES256)
                .generate();

        var secondaryKey = new ECKeyGenerator(Curve.P_256)
                .keyUse(KeyUse.SIGNATURE)
                .keyID("secondary-" + UUID.randomUUID().toString().substring(0, 8))
                .algorithm(com.nimbusds.jose.JWSAlgorithm.ES256)
                .generate();
        activeKeys = new ActiveKeys(primaryKey, secondaryKey);
        saveKeys();

        LOG.info("Successfully generated and stored initial keys");
        LOG.info("Primary key ID: {}", primaryKey.getKeyID());
        LOG.info("Secondary key ID: {}", secondaryKey.getKeyID());
    }

    private void loadKeys() throws Exception {
        String primaryJson = Files.readString(primaryKeyPath);
        String secondaryJson = Files.readString(secondaryKeyPath);

        var primaryKey = ECKey.parse(primaryJson);
        var secondaryKey = ECKey.parse(secondaryJson);
        activeKeys = new ActiveKeys(primaryKey, secondaryKey);

        LOG.info("Loaded existing keys from storage");
        LOG.info("Primary key ID: {}", primaryKey.getKeyID());
        LOG.info("Secondary key ID: {}", secondaryKey.getKeyID());
    }

    private void saveKeys() throws IOException {
        Files.writeString(primaryKeyPath, activeKeys.primary().toJSONString(),
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        Files.writeString(secondaryKeyPath, activeKeys.secondary().toJSONString(),
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        // Set restrictive permissions on Unix-like systems
        try {
            Files.setPosixFilePermissions(primaryKeyPath,
                    java.nio.file.attribute.PosixFilePermissions.fromString("rw-------"));
            Files.setPosixFilePermissions(secondaryKeyPath,
                    java.nio.file.attribute.PosixFilePermissions.fromString("rw-------"));
        } catch (UnsupportedOperationException e) {
            // Windows doesn't support POSIX permissions
            LOG.debug("Cannot set POSIX permissions on this platform");
        }
    }

    public synchronized void rotateKeys() throws JOSEException, IOException {
        LOG.info("Starting key rotation...");

        // Generate new primary
        var newPrimaryKey = new ECKeyGenerator(Curve.P_256)
                .keyUse(KeyUse.SIGNATURE)
                .keyID("primary-" + UUID.randomUUID().toString().substring(0, 8))
                .algorithm(com.nimbusds.jose.JWSAlgorithm.ES256)
                .generate();
        var newSecondary = activeKeys.primary();

        activeKeys = new ActiveKeys(newPrimaryKey, newSecondary);

        // Save to disk
        saveKeys();

        LOG.info("Key rotation completed successfully");
        LOG.info("New primary key ID: {}", activeKeys.primary().getKeyID());
    }

    public ECKey getPrimaryKey() {
        return activeKeys.primary();
    }

    public ECKey getSecondaryKey() {
        return activeKeys.secondary();
    }

    public Path getKeysDirectory() {
        return keysDirectory;
    }
}